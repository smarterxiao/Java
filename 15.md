# socket
![](/assets/740688-20150907234728090-211300057.jpg)
# Tcp
## client
 //客户端
 //1、创建客户端Socket，指定服务器地址和端口
 Socket socket =newSocket("localhost",10086);
 //2、获取输出流，向服务器端发送信息
 OutputStream os = socket.getOutputStream();//字节输出流
 PrintWriter pw =newPrintWriter(os);//将输出流包装成打印流
 pw.write("用户名：admin；密码：123");
 pw.flush();
 socket.shutdownOutput();
 //3、获取输入流，并读取服务器端的响应信息
 InputStream is = socket.getInputStream();
 BufferedReader br = new BufferedReader(new InputStreamReader(is));
 String info = null;
 while((info=br.readLine())!null){
  System.out.println("我是客户端，服务器说："+info);
 }
 
 //4、关闭资源
 br.close();
 is.close();
 pw.close();
 os.close();
 socket.close();
## server



```
  /**
   * 基于TCP协议的Socket通信，实现用户登录，服务端
  */
  //1、创建一个服务器端Socket，即ServerSocket，指定绑定的端口，并监听此端口
  ServerSocket serverSocket =newServerSocket(10086);//1024-65535的某个端口
  //2、调用accept()方法开始监听，等待客户端的连接
  Socket socket = serverSocket.accept();
  //3、获取输入流，并读取客户端信息
  InputStream is = socket.getInputStream();
 InputStreamReader isr =newInputStreamReader(is);
 BufferedReader br =newBufferedReader(isr);
 String info =null;
 while((info=br.readLine())!=null){
 System.out.println("我是服务器，客户端说："+info)；
 }
 socket.shutdownInput();//关闭输入流
 //4、获取输出流，响应客户端的请求
 OutputStream os = socket.getOutputStream();
 PrintWriter pw = new PrintWriter(os);
 pw.write("欢迎您！");
 pw.flush();
 
 
 //5、关闭资源
 pw.close();
 os.close();
 br.close();
 isr.close();
 is.close();
 socket.close();
 serverSocket.close();
```


# UDP
## server

```
 //服务器端，实现基于UDP的用户登录
 //1、创建服务器端DatagramSocket，指定端口
 DatagramSocket socket =new datagramSocket(10010);
 //2、创建数据报，用于接受客户端发送的数据
 byte[] data =newbyte[1024];//
 DatagramPacket packet =newDatagramPacket(data,data.length);
 //3、接受客户端发送的数据
 socket.receive(packet);//此方法在接受数据报之前会一致阻塞
 //4、读取数据
 String info =newString(data,o,data.length);
 System.out.println("我是服务器，客户端告诉我"+info);
 
 
 //=========================================================
 //向客户端响应数据
 //1、定义客户端的地址、端口号、数据
 InetAddress address = packet.getAddress();
 int port = packet.getPort();
 byte[] data2 = "欢迎您！".geyBytes();
 //2、创建数据报，包含响应的数据信息
 DatagramPacket packet2 = new DatagramPacket(data2,data2.length,address,port);
 //3、响应客户端
 socket.send(packet2);
 //4、关闭资源
 socket.close();
```
##client
 //客户端
//1、定义服务器的地址、端口号、数据
 InetAddress address =InetAddress.getByName("localhost");
 int port =10010;
 byte[] data ="用户名：admin;密码：123".getBytes();
 //2、创建数据报，包含发送的数据信息
 DatagramPacket packet = newDatagramPacket(data,data,length,address,port);
 //3、创建DatagramSocket对象
 DatagramSocket socket =newDatagramSocket();
 //4、向服务器发送数据
 socket.send(packet);
 
 
 //接受服务器端响应数据
 //======================================
 //1、创建数据报，用于接受服务器端响应数据
 byte[] data2 = new byte[1024];
 DatagramPacket packet2 = new DatagramPacket(data2,data2.length);
 //2、接受服务器响应的数据
 socket.receive(packet2);
 String raply = new String(data2,0,packet2.getLenth());
 System.out.println("我是客户端，服务器说："+reply);
 //4、关闭资源
 socket.close();

# 网络协议
## Http
### 媒体类型
因特网上有数千种不同的数据类型，HTTP 仔细地给每种要通过 Web 传输的对象都打上了名为 MIME 类型 （MIME type）的数据格式标签。最初设计 MIME 类型是一种文本标记，表示一种主要的对象类型和一个特定的子类型，中间由一条斜杠来分隔。

* 普通的 ASCII 文本文档由 text/plain 类型来标记。
* JPEG 格式的图片为 image/jpeg 类型。 
* GIF 格式的图片为 image/gif 类型。 
* Apple 的 QuickTime 电影为 video/quicktime 类型。
*  微软的 PowerPoint 演示文件为 application/vnd.ms-powerpoint 类型。
### URI 统一资源标识符
分为
*  URL 统一资源定位符（URL）是资源标识符最常见的形式
大部分 URL 都遵循一种标准格式，这种格式包含三个部分。
 *  URL 的第一部分被称为 方案 （scheme），说明了访问资源所使用的协议类型。这部分通常就是 HTTP 协议（http://）。
 *  第二部分给出了服务器的因特网地址（比如，www.joes-hardware.com ）。 
 * 其余部分指定了 Web 服务器上的某个资源（比如，/specials/saw-blade.gif）。 现在，几乎所有的 URI 都是 URL。


* URN 的第二种形式就是统一资源名（URN）。
URN的第二种形式就是统一资源名（URN）。URN 是作为特定内容的唯一名称使用的，与目前的资源所在地无关。使用这些与位置无关的,**但是现在还没有使用**

* 所以现在的URI和URL在某种程度上是等价的。

###　Web页面中可以包含多个对象
应用程序完成一项任务时通常会发布多个 HTTP 事务。比如，Web 浏览器会发布一系列 HTTP 事务来获取并显示一个包含了丰富图片的 Web 页面。浏览器会执行一个事务来获取描述页面布局的 HTML“框架”，然后发布另外的 HTTP 事务来获取每个嵌入式图片、图像面板、Java 小程序等。这些嵌入式资源甚至可能位于不同的服务器上，如图 1-6 所示。因此，一个“Web 页面”通常并不是单个资源，而是一组资源的集合。

##http 报文
![](/assets/2017-02-17 15 24 19.png)

* **起始行** 报文的第一行就是起始行，在请求报文中用来说明要做些什么，在响应报文中说明出现了什么情况。 
* **首部字段** 起始行后面有零个或多个首部字段。每个首部字段都包含一个名字和一个值，为了便于解析，两者之间用冒号（:）来分隔。首部以一个空行结束。添加一个首部字段和添加新行一样简单。 
* **主体** 空行之后就是可选的报文主体了，其中包含了所有类型的数据。请求主体中包括了要发送给 Web 服务器的数据；响应主体中装载了要返回给客户端的数据。起始行和首部都是文本形式且都是结构化的，而主体则不同，主体中可以包含任意的二进制数据（比如图片、视频、音轨、软件程序）。当然，主体中也可以包含文本。

![](/assets/2017-02-17 15 26 02.png)
## TCP IP协议
![](/assets/2017-02-17 15 30 24.png)

![](/assets/2017-02-17 15 32 22.png)

步骤如下： 
(a) 浏览器从 URL 中解析出服务器的主机名；
(b) 浏览器将服务器的主机名转换成服务器的 IP 地址；
(c) 浏览器将端口号（如果有的话）从 URL 中解析出来；
(d) 浏览器建立一条与 Web 服务器的 TCP 连接； 
(e) 浏览器向服务器发送一条 HTTP 请求报文；
(f) 服务器向浏览器回送一条 HTTP 响应报文；
(g) 关闭连接，浏览器显示文档。

## URI和资源
比如说，你想要获取 URL http://www.joes-hardware.com/seasonal/index-fall.html 。那么 URL 分以下三部分。
* URL 的第一部分（http）是 URL 方案 （scheme）。方案可以告知 Web 客户端 怎样 访问资源。在这个例子中，URL 说明要使用 HTTP 协议。
* URL 的第二部分（www.joes-hardware.com）指的是服务器的位置。这部分告知 Web 客户端资源 位于何处 。
* URL 的第三部分（/seasonal/index-fall.html）是资源路径。路径说明了请求的是服务器上

URL可以通过HTTP之外的其他协议来访问资源。它们可以指向因特网上的任意资源
![](/assets/2017-02-17 16 14 12.png)
**三个例子： **
个人的email账户： mailto:president@whitehouse.gov 
通过其他协议（比如FTP协议）访问的各种文件： ftp://ftp.lots-o-books.com/pub/complete-price-list.xls 
从流视频服务器上下载电影： rtsp://www.joes-hardware.com:554/interview/cto_video


这个是URI的规则
```
<scheme>://<user>:<password>@<host>:<port>/<path>;<params>?<query>#<frag>
```
中包含了所有这些组件。URL 最重要的 3 个部分是 方案 （scheme）、 主机 （host）和 路径 （path）。表


|  组　　件 |  描　　述  |  默　认　值  |
| --- | :---: | ---: |
| 方案 |  访问服务器以获取资源时要使用哪种协议 | 无 |
| 用户 |  某些方案访问资源时需要的用户名 |匿名 |
|密码 |  用户名后面可能要包含的密码，中间由冒号（:）分隔  | <E-mail地址> |
|主机| 资源宿主服务器的主机名或点分IP地址|无|
|端口|资源宿主服务器正在监听的端口号。很多方案都有默认端口号（HTTP的默认端口号为80）|每个方案特有|
|路径   | 服务器上资源的本地名，由一个斜杠（/）将其与前面的URL组件分隔开来。路径组件的语法是与服务器和方案有关的（本章稍后会讲到URL路径可以分为若干个段，每段都可以有其特有的组件。）| 无|
|参数|某些方案会用这个组件来指定输入参数。参数为名/值对。URL中可以包含多个参数字段，它们相互之间以及与路径的其余部分之间用分号（;）分隔|无|
| 查询|某些方案会用这个组件传递参数以激活应用程序（比如数据库、公告板、搜索引擎以及其他因特网网关）。查询组件的内容没有通用格式。用字符“?”将其与URL的其余部分分隔开来| 无|
|片段|一小片或一部分资源的名字。引用对象时，不会将frag字段传送给服务器；这个字段是在客户端内部使用的。通过字符“#”将其与URL的其余部分分隔开来|无|
* 用户和密码

ftp://anonymous:my_passwd@ftp.prep.ai.mit.edu/pub/gnu
FTP，但用户没有提供，它通常会插入一个默认的用户名和密码。比如，如果向浏览器提供一个 FTP URL，但没有指定用户名和密码，它就会插入 anonymous（匿名用户）作为你的用户名，并发送一个默认的密码（Internetanonymous（匿名用户）作为你的用户名，并发送一个默认的密码（Internet Explorer 会发送 IEUser，Netscape Navigator 则会发送 mozilla）。
* 参数
http://www.joes-hardware.com/hammers;sale=false/index.html;graphics=true
*  查询
http://www.joes-hardware.com/inventory-check.cgi?item=12731
* 片段
有些资源类型，比如 HTML，除了资源级之外，还可以做进一步的划分。比如，对一个带有章节的大型文本文档来说，资源的 URL 会指向整个文本文档，但理想的情况是，能够指定资源中的那些章节。 为了引用部分资源或资源的一个片段，URL 支持使用 片段 （frag）组件来表示一个资源内部的片段。比如，URL 可以指向 HTML 文档中一个特定的图片或小节。 片段挂在 URL 的右手边，最前面有一个字符“#”。比如： http://www.joes-hardware.com/tools.html#drills 在这个例子中，片段 drills 引用了 Joe 的五金商店 Web 服务器上页面 /tools.html 中的一个部分。这部分的名字叫做 drills。
![](/assets/2017-02-17 17 20 19.png)

## http报文
### 这是请求报文的格式：


```
<method> <request-URL> <version>  请求首行
<headers> 请求头
<entity-body> 请求体
```
####方法 （method） 
客户端希望服务器对资源执行的动作。是一个单独的词，比如 GET、HEAD 或 POST。本章稍后将详细介绍方法。 
####请求 URL（request-URL）
 命名了所请求资源，或者 URL 路径 组件的完整 URL。如果直接与服务器进行对话，只要 URL 的路径组件是资源的绝对路径，通常就不会有什么问题——服务器可以假定自己是 URL 的主机 / 端口。第 2 章详细地介绍了 URL 的语法。 
 #### 版本 （version）
 报文所使用的 HTTP 版本，其格式看起来是这样的： HTTP/<major>.<minor> 其中 主要版本号（major）和次要版本号（minor）都是整数。本章稍后会详细说明 HTTP 的版本问题。
 
#### 状态码 （status-code）、
这三位数字描述了请求过程中所发生的情况。每个状态码的第一位数字都用于描述状态的一般类别（“成功”、“出错”等）。本章稍后提供了 HTTP 规范定义的状态码及其含义的完整列表。
#### 原因短语 （reason-phrase）

数字状态码的可读版本，包含行终止序列之前的所有文本。本章稍后提供了 HTTP 规范定义的所有状态码的原因短语示例。原因短语只对人类有意义，因此，比如说，尽管响应行 HTTP/1.0 200 NOT OK 和 HTTP/1.0 200 OK 中原因短语的含义不同，但同样都会被当作成功指示处理。 
####首部 （header）
 可以有零个或多个首部，每个首部都包含一个名字，后面跟着一个冒号（:），然后是一个可选的空格，接着是一个值，最后是一个 CRLF。首部是由一个空行（CRLF）结束的，表示了首部列表的结束和实体主体部分的开始。有些 HTTP 版本，比如 HTTP/1.1，要求有效的请求或响应报文中必须包含特定的首部。本章稍后会探讨各种 HTTP 首部。 
#### 实体的主体部分（entity-body）
 实体的主体部分包含一个由任意数据组成的数据块。并不是所有的报文都包含实体的主体部分，有时，报文只是以一个 CRLF 结束。第 15 章详述了实体。


### 这是响应报文的格式：




```
<version> <status> <reason-phrase> 
<headers>
 <entity-body>
```

![](/assets/2017-02-17 17 43 50.png)

### 起始行

* 请求行
 请求报文请求服务器对资源进行一些操作。请求报文的起始行，或称为 请求行 ，包含了一个方法和一个请求 URL，这个方法描述了服务器应该执行的操作，请求 URL 描述了要对哪个资源执行这个方法。请求行中还包含 HTTP 的版本，用来告知服务器，客户端使用的是哪种 HTTP。 所有这些字段都由空格符分隔。在图 3-5a 中，请求方法为 GET，请求 URL 为/test/hi-there.txt，版本为 HTTP/1.1。在 HTTP/1.0 之前，并不要求请求行中包含 HTTP 版本号。
* 响应行 
 响应报文承载了状态信息和操作产生的所有结果数据，将其返回给客户端。响应报文的起始行，或称为 响应行 ，包含了响应报文使用的 HTTP 版本、数字状态码，以及描述操作状态的文本形式的原因短语。 所有这些字段都由空格符进行分隔。在图 3-5b 中，HTTP 版本为 HTTP/1.0，状态码为 200（表示成功），原因短语为 OK，表示文档已经被成功返回了。在 HTTP/1.0 之前，并不要求在响应中包含响应行。
* 方法 
请求的起始行以方法作为开始，方法用来告知服务器要做些什么。比如，在行“GET /specials/saw-blade.gif HTTP/1.0”中，方法就是 GET。 HTTP 规范中定义了一组常用的请求方法。比如，GET 方法负责从服务器获取一个文档，POST 方法会向服务器发送需要处理的数据，OPTIONS 方法用于确定 Web 服务器的一般功能，或者 Web 服务器处理特定资源的能力。
      
|  方　　法 | 描　　述 |  是否包含主体|
| --- | :---: | ---: |
|GET   |从服务器获取一份文档| 否|
|HEAD|只从服务器获取文档的首部|否|
|POST|向服务器发送需要处理的数据 |是|
| PUT|将请求的主体部分存储在服务器上| 是|
|TRACE| 对可能经过代理服务器传送到服务器上去的报文进行追踪|否|
|OPTIONS|决定可以在服务器上执行哪些方法|否|
| DELETE| 从服务器上删除一份文档  | 否|
###状态码
状态码分类

|   整体范围  |已定义范围  | 分　　类|
| --- | :---: | ---: |
|100～199|100～101|信息提示|
|200～299|200～206|成功|
|300～399|300～305|重定向|
|400～499|400～415|客户端错误|
|500～599|500～505|服务器错误 |
###原因短语 
原因短语是响应起始行中的最后一个组件。它为状态码提供了文本形式的解释。比如，在行 HTTP/1.0 200 OK 中，OK 就是原因短语。 原因短语和状态码是成对出现的。原因短语是状态码的可读版本，应用程序开发者将其传送给用户，用以说明在请求期间发生了什么情况。 HTTP 规范并没有提供任何硬性规定，要求原因短语以何种形式出现。本章稍后列出了状态码和一些建议使用的原因短语。
### 首部分类
|  首部实例  |描　　述 | 
| --- | :---: |
| Date:Tue,3Oct 1997 02:16:03 GMT| 服务器产生响应的日期|
|Content-length:15040|实体的主体部分包含了15 040字节的数据|
|Content-type:image/gif |实体的主体部分是一个GIF图片|
|Accept: image/gif, image/jpeg, text/html| 客户端可以接收GIF图片和JPEG图片以及HTML |

![](/assets/2017-02-17 18 02 01.png)
![](/assets/2017-02-17 18 03 13.png)
![](/assets/2017-02-17 18 03 34.png)
![](/assets/2017-02-17 18 05 08.png)
![](/assets/2017-02-17 18 10 28.png)
![](/assets/2017-02-17 18 10 49.png)
![](/assets/2017-02-17 18 11 27.png)
### 状态码
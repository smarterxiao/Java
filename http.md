# 网络协议
## Http
### 媒体类型
因特网上有数千种不同的数据类型，HTTP 仔细地给每种要通过 Web 传输的对象都打上了名为 MIME 类型 （MIME type）的数据格式标签。最初设计 MIME 类型是一种文本标记，表示一种主要的对象类型和一个特定的子类型，中间由一条斜杠来分隔。

* 普通的 ASCII 文本文档由 text/plain 类型来标记。
* JPEG 格式的图片为 image/jpeg 类型。 
* GIF 格式的图片为 image/gif 类型。 
* Apple 的 QuickTime 电影为 video/quicktime 类型。
*  微软的 PowerPoint 演示文件为 application/vnd.ms-powerpoint 类型。
### URI 统一资源标识符
分为
*  URL 统一资源定位符（URL）是资源标识符最常见的形式
大部分 URL 都遵循一种标准格式，这种格式包含三个部分。
 *  URL 的第一部分被称为 方案 （scheme），说明了访问资源所使用的协议类型。这部分通常就是 HTTP 协议（http://）。
 *  第二部分给出了服务器的因特网地址（比如，www.joes-hardware.com ）。 
 * 其余部分指定了 Web 服务器上的某个资源（比如，/specials/saw-blade.gif）。 现在，几乎所有的 URI 都是 URL。


* URN 的第二种形式就是统一资源名（URN）。
URN的第二种形式就是统一资源名（URN）。URN 是作为特定内容的唯一名称使用的，与目前的资源所在地无关。使用这些与位置无关的,**但是现在还没有使用**

* 所以现在的URI和URL在某种程度上是等价的。

###　Web页面中可以包含多个对象
应用程序完成一项任务时通常会发布多个 HTTP 事务。比如，Web 浏览器会发布一系列 HTTP 事务来获取并显示一个包含了丰富图片的 Web 页面。浏览器会执行一个事务来获取描述页面布局的 HTML“框架”，然后发布另外的 HTTP 事务来获取每个嵌入式图片、图像面板、Java 小程序等。这些嵌入式资源甚至可能位于不同的服务器上，如图 1-6 所示。因此，一个“Web 页面”通常并不是单个资源，而是一组资源的集合。

##http 报文
![](/assets/2017-02-17 15 24 19.png)

* **起始行** 报文的第一行就是起始行，在请求报文中用来说明要做些什么，在响应报文中说明出现了什么情况。 
* **首部字段** 起始行后面有零个或多个首部字段。每个首部字段都包含一个名字和一个值，为了便于解析，两者之间用冒号（:）来分隔。首部以一个空行结束。添加一个首部字段和添加新行一样简单。 
* **主体** 空行之后就是可选的报文主体了，其中包含了所有类型的数据。请求主体中包括了要发送给 Web 服务器的数据；响应主体中装载了要返回给客户端的数据。起始行和首部都是文本形式且都是结构化的，而主体则不同，主体中可以包含任意的二进制数据（比如图片、视频、音轨、软件程序）。当然，主体中也可以包含文本。

![](/assets/2017-02-17 15 26 02.png)
## TCP IP协议
![](/assets/2017-02-17 15 30 24.png)

![](/assets/2017-02-17 15 32 22.png)

步骤如下： 
(a) 浏览器从 URL 中解析出服务器的主机名；
(b) 浏览器将服务器的主机名转换成服务器的 IP 地址；
(c) 浏览器将端口号（如果有的话）从 URL 中解析出来；
(d) 浏览器建立一条与 Web 服务器的 TCP 连接； 
(e) 浏览器向服务器发送一条 HTTP 请求报文；
(f) 服务器向浏览器回送一条 HTTP 响应报文；
(g) 关闭连接，浏览器显示文档。

## URI和资源
比如说，你想要获取 URL http://www.joes-hardware.com/seasonal/index-fall.html 。那么 URL 分以下三部分。
* URL 的第一部分（http）是 URL 方案 （scheme）。方案可以告知 Web 客户端 怎样 访问资源。在这个例子中，URL 说明要使用 HTTP 协议。
* URL 的第二部分（www.joes-hardware.com）指的是服务器的位置。这部分告知 Web 客户端资源 位于何处 。
* URL 的第三部分（/seasonal/index-fall.html）是资源路径。路径说明了请求的是服务器上

URL可以通过HTTP之外的其他协议来访问资源。它们可以指向因特网上的任意资源
![](/assets/2017-02-17 16 14 12.png)
**三个例子： **
个人的email账户： mailto:president@whitehouse.gov 
通过其他协议（比如FTP协议）访问的各种文件： ftp://ftp.lots-o-books.com/pub/complete-price-list.xls 
从流视频服务器上下载电影： rtsp://www.joes-hardware.com:554/interview/cto_video


这个是URI的规则
```
<scheme>://<user>:<password>@<host>:<port>/<path>;<params>?<query>#<frag>
```
中包含了所有这些组件。URL 最重要的 3 个部分是 方案 （scheme）、 主机 （host）和 路径 （path）。表


|  组　　件 |  描　　述  |  默　认　值  |
| --- | :---: | ---: |
| 方案 |  访问服务器以获取资源时要使用哪种协议 | 无 |
| 用户 |  某些方案访问资源时需要的用户名 |匿名 |
|密码 |  用户名后面可能要包含的密码，中间由冒号（:）分隔  | <E-mail地址> |
|主机| 资源宿主服务器的主机名或点分IP地址|无|
|端口|资源宿主服务器正在监听的端口号。很多方案都有默认端口号（HTTP的默认端口号为80）|每个方案特有|
|路径   | 服务器上资源的本地名，由一个斜杠（/）将其与前面的URL组件分隔开来。路径组件的语法是与服务器和方案有关的（本章稍后会讲到URL路径可以分为若干个段，每段都可以有其特有的组件。）| 无|
|参数|某些方案会用这个组件来指定输入参数。参数为名/值对。URL中可以包含多个参数字段，它们相互之间以及与路径的其余部分之间用分号（;）分隔|无|
| 查询|某些方案会用这个组件传递参数以激活应用程序（比如数据库、公告板、搜索引擎以及其他因特网网关）。查询组件的内容没有通用格式。用字符“?”将其与URL的其余部分分隔开来| 无|
|片段|一小片或一部分资源的名字。引用对象时，不会将frag字段传送给服务器；这个字段是在客户端内部使用的。通过字符“#”将其与URL的其余部分分隔开来|无|
* 用户和密码

ftp://anonymous:my_passwd@ftp.prep.ai.mit.edu/pub/gnu
FTP，但用户没有提供，它通常会插入一个默认的用户名和密码。比如，如果向浏览器提供一个 FTP URL，但没有指定用户名和密码，它就会插入 anonymous（匿名用户）作为你的用户名，并发送一个默认的密码（Internetanonymous（匿名用户）作为你的用户名，并发送一个默认的密码（Internet Explorer 会发送 IEUser，Netscape Navigator 则会发送 mozilla）。
* 参数
http://www.joes-hardware.com/hammers;sale=false/index.html;graphics=true
*  查询
http://www.joes-hardware.com/inventory-check.cgi?item=12731
* 片段
有些资源类型，比如 HTML，除了资源级之外，还可以做进一步的划分。比如，对一个带有章节的大型文本文档来说，资源的 URL 会指向整个文本文档，但理想的情况是，能够指定资源中的那些章节。 为了引用部分资源或资源的一个片段，URL 支持使用 片段 （frag）组件来表示一个资源内部的片段。比如，URL 可以指向 HTML 文档中一个特定的图片或小节。 片段挂在 URL 的右手边，最前面有一个字符“#”。比如： http://www.joes-hardware.com/tools.html#drills 在这个例子中，片段 drills 引用了 Joe 的五金商店 Web 服务器上页面 /tools.html 中的一个部分。这部分的名字叫做 drills。
![](/assets/2017-02-17 17 20 19.png)

## http报文
### 这是请求报文的格式：
```
<method> <request-URL> <version>  请求首行
<headers> 请求头
<entity-body> 请求体
```
####方法 （method） 
客户端希望服务器对资源执行的动作。是一个单独的词，比如 GET、HEAD 或 POST。本章稍后将详细介绍方法。 
####请求 URL（request-URL）
 命名了所请求资源，或者 URL 路径 组件的完整 URL。如果直接与服务器进行对话，只要 URL 的路径组件是资源的绝对路径，通常就不会有什么问题——服务器可以假定自己是 URL 的主机 / 端口。第 2 章详细地介绍了 URL 的语法。 
 #### 版本 （version）
 报文所使用的 HTTP 版本，其格式看起来是这样的： HTTP/<major>.<minor> 其中 主要版本号（major）和次要版本号（minor）都是整数。本章稍后会详细说明 HTTP 的版本问题。
 
#### 状态码 （status-code）、
这三位数字描述了请求过程中所发生的情况。每个状态码的第一位数字都用于描述状态的一般类别（“成功”、“出错”等）。本章稍后提供了 HTTP 规范定义的状态码及其含义的完整列表。
#### 原因短语 （reason-phrase）

数字状态码的可读版本，包含行终止序列之前的所有文本。本章稍后提供了 HTTP 规范定义的所有状态码的原因短语示例。原因短语只对人类有意义，因此，比如说，尽管响应行 HTTP/1.0 200 NOT OK 和 HTTP/1.0 200 OK 中原因短语的含义不同，但同样都会被当作成功指示处理。 
####首部 （header）
 可以有零个或多个首部，每个首部都包含一个名字，后面跟着一个冒号（:），然后是一个可选的空格，接着是一个值，最后是一个 CRLF。首部是由一个空行（CRLF）结束的，表示了首部列表的结束和实体主体部分的开始。有些 HTTP 版本，比如 HTTP/1.1，要求有效的请求或响应报文中必须包含特定的首部。本章稍后会探讨各种 HTTP 首部。 
#### 实体的主体部分（entity-body）
 实体的主体部分包含一个由任意数据组成的数据块。并不是所有的报文都包含实体的主体部分，有时，报文只是以一个 CRLF 结束。第 15 章详述了实体。


### 这是响应报文的格式：




```
<version> <status> <reason-phrase> 
<headers>
 <entity-body>
```

![](/assets/2017-02-17 17 43 50.png)

### 起始行

* 请求行
 请求报文请求服务器对资源进行一些操作。请求报文的起始行，或称为 请求行 ，包含了一个方法和一个请求 URL，这个方法描述了服务器应该执行的操作，请求 URL 描述了要对哪个资源执行这个方法。请求行中还包含 HTTP 的版本，用来告知服务器，客户端使用的是哪种 HTTP。 所有这些字段都由空格符分隔。在图 3-5a 中，请求方法为 GET，请求 URL 为/test/hi-there.txt，版本为 HTTP/1.1。在 HTTP/1.0 之前，并不要求请求行中包含 HTTP 版本号。
* 响应行 
 响应报文承载了状态信息和操作产生的所有结果数据，将其返回给客户端。响应报文的起始行，或称为 响应行 ，包含了响应报文使用的 HTTP 版本、数字状态码，以及描述操作状态的文本形式的原因短语。 所有这些字段都由空格符进行分隔。在图 3-5b 中，HTTP 版本为 HTTP/1.0，状态码为 200（表示成功），原因短语为 OK，表示文档已经被成功返回了。在 HTTP/1.0 之前，并不要求在响应中包含响应行。
* 方法 
请求的起始行以方法作为开始，方法用来告知服务器要做些什么。比如，在行“GET /specials/saw-blade.gif HTTP/1.0”中，方法就是 GET。 HTTP 规范中定义了一组常用的请求方法。比如，GET 方法负责从服务器获取一个文档，POST 方法会向服务器发送需要处理的数据，OPTIONS 方法用于确定 Web 服务器的一般功能，或者 Web 服务器处理特定资源的能力。
      
-----

|  方　　法 | 描　　述 |  是否包含主体|
| --- | :---: | ---: |
|GET   |从服务器获取一份文档| 否|
|HEAD|只从服务器获取文档的首部|否|
|POST|向服务器发送需要处理的数据 |是|
| PUT|将请求的主体部分存储在服务器上| 是|
|TRACE| 对可能经过代理服务器传送到服务器上去的报文进行追踪|否|
|OPTIONS|决定可以在服务器上执行哪些方法|否|
| DELETE| 从服务器上删除一份文档  | 否|
###状态码
状态码分类

|   整体范围  |已定义范围  | 分　　类|
| --- | :---: | ---: |
|100～199|100～101|信息提示|
|200～299|200～206|成功|
|300～399|300～305|重定向|
|400～499|400～415|客户端错误|
|500～599|500～505|服务器错误 |
###原因短语 
原因短语是响应起始行中的最后一个组件。它为状态码提供了文本形式的解释。比如，在行 HTTP/1.0 200 OK 中，OK 就是原因短语。 原因短语和状态码是成对出现的。原因短语是状态码的可读版本，应用程序开发者将其传送给用户，用以说明在请求期间发生了什么情况。 HTTP 规范并没有提供任何硬性规定，要求原因短语以何种形式出现。本章稍后列出了状态码和一些建议使用的原因短语。
### 首部分类
|  首部实例  |描　　述 | 
| --- | :---: |
| Date:Tue,3Oct 1997 02:16:03 GMT| 服务器产生响应的日期|
|Content-length:15040|实体的主体部分包含了15 040字节的数据|
|Content-type:image/gif |实体的主体部分是一个GIF图片|
|Accept: image/gif, image/jpeg, text/html| 客户端可以接收GIF图片和JPEG图片以及HTML |

![](/assets/2017-02-17 18 02 01.png)
![](/assets/2017-02-17 18 03 13.png)
![](/assets/2017-02-17 18 03 34.png)
![](/assets/2017-02-17 18 05 08.png)
![](/assets/2017-02-17 18 10 28.png)
![](/assets/2017-02-17 18 10 49.png)
![](/assets/2017-02-17 18 11 27.png)
### 状态码
* 　100～199——信息性状态码

|状　态　码| 原因短语|含　　义 |
| --- | :---: |---|
|100| Continue|说明收到了请求的初始部分，请客户端继续。发送了这个状态码之后，服务器在收到请求之后必须进行响应。更多信息请参见附录C中的Expect  首部介绍 |
| 101 |  Switching Protocols  | 说明服务器正在根据客户端的指定，将协议切换成Update 首部所列的协议|
| 200  | OK   |请求没问题，实体的主体部分包含了所请求的资源  |

* 　200～299——成功状态码

|状　态　码| 原因短语|含　　义 |
| --- | :---: |---|
| 201   |Created  | 用于创建服务器对象的请求（比如，PUT）。响应的实体主体部分中应该包含各种引用了已创建的资源的URL，Location首部包含的则是最具体的引用。更多有关Location首部的信息参见表3-21。  服务器必须在发送这个状态码之前创建好对象 |
| 202  | Accepted|   请求已被接受，但服务器还未对其执行任何动作。不能保证服务器会完成这个请求；这只是意味着接受请求时，它看起来是有效的。  服务器应该在实体的主体部分包含对请求状态的描述，或许还应该有对请求完成时间的估计（或者包含一个指针，指向可以获取此信息的位置）|
|  203 |  Non-Authoritative Information |  实体首部（更多有关实体首部的信息参见3.5.4节）包含的信息不是来自于源端服务器，而是来自资源的一份副本。如果中间节点上有一份资源副本，但无法或者没有对它所发送的与资源有关的元信息（首部）进行验证，就会出现这种情况。  这种响应码并不是非用不可的；如果实体首部来自源端服务器，响应为200状态的应用程序就可以将其作为一种可选项使用|
 |204  | No Content|   响应报文中包含若干首部和一个状态行，但没有实体的主体部分。主要用于在浏览器不转为显示新文档的情况下，对其进行更新（比如刷新一个表单页面） |
|  205 |  Reset Content  | 另一个主要用于浏览器的代码。负责告知浏览器清除当前页面中的所有HTML 表单元素   |
|206  | Partial Content  | 成功执行了一个部分或Range（范围）请求。稍后我们会看到，客户端可以通过一些特殊的首部来获取部分或某个范围内的文档——这个状态码就说明范围请求成功了。更多有关Range首部的内容参见15.9节。 206响应中必须包含Content-Range 、 Date 以及以及 ETag 或 Content-Location  首部 |

* 　300～399——重定向状态码

![](/assets/2017-02-17 18 23 32.png)
![](/assets/2017-02-17 18 23 38.png)

|状　态　码| 原因短语|含　　义 |
| --- | :---: |---|
| 300  | Multiple Choices  | 客户端请求一个实际指向多个资源的URL时会返回这个状态码，比如服务器上有某个HTML文档的英语和法语版本。返回这个代码时会带有一个选项列表；这样用户就可以选择他希望使用的那一项了。有多个版本可用时，客户端需要沟通解决，更多与此有关的信息请参见第17章。服务器可以在Location 首部包含首选URL |
| 301  | Moved Permanently |  在请求的URL已被移除时使用。响应的Location 首部中应该包含资源现在所处的URL|
|  302 |  Found   |与301状态码类似；但是，客户端应该使用Location 首部给出的URL来临时定位资源。将来的请求仍应使用老的URL |
| 303  | See Other|   告知客户端应该用另一个URL来获取资源。新的URL位于响应报文的 Location  首部。其主要目的是允许POST请求的响应将客户端定向到某个资源上去 |
| 304 |  Not Modified |  客户端可以通过所包含的请求首部，使其请求变成有条件的。更多有关条件首部的内容请参见第3章。如果客户端发起了一个条件GET请求，而最近资源未被修改的话，就可以用这个状态码来说明资源未被修改。带有这个状态码的响应不应该包含实体的主体部分 |
|305   |Use Proxy  | 用来说明必须通过一个代理来访问资源；代理的位置由Location 首部给出。很重要的一点是，客户端是相对某个特定资源来解析这条响应的，不能假定所有请求，甚至所有对持有所请求资源的服务器的请求都通过这个代理进行。如果客户端错误地让代理介入了某条请求，可能会引发破坏性的行为，而且会造成安全漏洞 |
| 306   |（未使用）|   当前未使用 |
|  307  | Temporary Redirect   |与301状态码类似；但客户端应该使用Location 首部给出的URL来临时定位资源。将来的请求应该使用老的URL|

*　400～499——客户端错误状态码

|状　态　码| 原因短语|含　　义 |
| --- | :---: |---|
| 400 |  Bad Request |  用于告知客户端它发送了一个错误的请求   401   Unauthorized   与适当的首部一同返回，在这些首部中请求客户端在获取对资源的访问权之前，对自己进行认证。更多有关认证的内容请参见 12.1节|
|   402  | Payment Required  | 现在这个状态码还未使用，但已经被保留，以作未来之用  |
| 403   |Forbidden   |用于说明请求被服务器拒绝了。如果服务器想说明为什么拒绝请求，可以包含实体的主体部分来对原因进行描述。但这个状态码通常是在服务器不想说明拒绝原因的时候使用的  |
|404  | Not Found |  用于说明服务器无法找到所请求的URL。通常会包含一个实体，以便客户端应用程序显示给用户看 |
|  405|   Method Not Allowed  | 发起的请求中带有所请求的URL不支持的方法时，使用此状态码。应该在响应中包含Allow首部，以告知客户端对所请求的资源可以使用哪些方法。更多有关Allow 首部的信息请参见3.5.4节|
|  406 |  Not Acceptable |  客户端可以指定参数来说明它们愿意接收什么类型的实体。服务器没有与客户端可接受的URL相匹配的资源时，使用此代码。通常，服务器会包含一些首部，以便客户端弄清楚为什么请求无法满足。更多信息请参见第17章 |
|  407  | Proxy Authentication Required  | 与401状态码类似，但用于要求对资源进行认证的代理服务器  |
| 408  | Request Timeout  | 如果客户端完成请求所花的时间太长，服务器可以回送此状态码，并关闭连接。超时时长随服务器的不同有所不同，但通常对所有的合法请求来说，都是够长的 |
|  409 |  Conflict  | 用于说明请求可能在资源上引发的一些冲突。服务器担心请求会引发冲突时，可以发送此状态码。响应中应该包含描述冲突的主体|
|   410 |  Gone  | 与404类似，只是服务器曾经拥有过此资源。主要用于Web站点的维护，这样服务器的管理者就可以在资源被移除的情况下通知客户端了 |
| 411   |Length Required  | 服务器要求在请求报文中包含Content-Length首部时使用。更多有关Content-Length 首部的信息请参见3.5.4节  |
|412 |  Precondition Failed|   客户端发起了条件请求，且其中一个条件失败了的时候使用。客户端包含了Expect首部时发起的就是条件请求。更多有关Expect首部的内容请参见附录C中Expect  部分|
|  413 |  Request Entity Too Large   |客户端发送的实体主体部分比服务器能够或者希望处理的要大时，使用此状态码 |
|  414 |  Request URI Too Long |  客户端所发请求中的请求URL比服务器能够或者希望处理的要长时，使用此状态码 |
|  415  | Unsupported Media Type|   服务器无法理解或无法支持客户端所发实体的内容类型时，使用此状态码|
| 416 |  Requested Range Not Satisfiable   |请求报文所请求的是指定资源的某个范围，而此范围无效或无法满足时，使用此状态码|
|   417 |  Expectation Failed  | 请求的Expect请求首部包含了一个期望，但服务器无法满足此期望时，使用此状态码。更多有关Expect首部的内容请参见附录C中Expect 部分  如果代理或其他中间应用程序有确切证据说明源端服务器会为某请求产生一个失败的期望，就可以发送这个响应状态码|

* 　服务器错误状态码及原因短语 
|状　态　码| 原因短语|含　　义 |
| --- | :---: |---|
|  500 |  Internal Server Error  | 服务器遇到一个妨碍它为请求提供服务的错误时，使用此状态码  |
| 501 |  Not Implemented  | 客户端发起的请求超出服务器的能力范围（比如，使用了服务器不支持的请求方法）时，使用此状态码 | 
| 502 |  Bad Gateway |  作为代理或网关使用的服务器从请求响应链的下一条链路上收到了一条伪响应（比如，它无法连接到其父网关）时，使用此状态码|
|   503 |  Service Unavailable |  用来说明服务器现在无法为请求提供服务，但将来可以。如果服务器知道什么时候资源会变为可用的，可以在响应中包含一个Retry-After首部。更多有关Retry-After 首部的信息请参见3.5.3节  |
|504  | Gateway Timeout|   与状态码408类似，只是这里的响应来自一个网关或代理，它们在等待另一服务器对其请求进行响应时超时了 |
|  505 |  HTTP Version Not Supported |  服务器收到的请求使用了它无法或不愿支持的协议版本时，使用此状态码。有些服务器应用程序会选择不支持协议的早期版本 |


## 首部 
### 通用首部
> 有些首部提供了与报文相关的最基本的信息，它们被称为通用首部。它们像和事佬儿一样，不论报文是何类型，都为其提供一些有用信息。
#### 信息性首部
| 首　　部  | 描　　述 |
| --- | --- |
| Connection |  允许客户端和服务器指定与请求/响应连接有关的选项 |
|  Date1  | 提供日期和时间标志，说明报文是什么时间创建的   |
|MIME-Version   |给出了发送端使用的MIME版本 |
|  Trailer  | 如果报文采用了分块传输编码（chunked transfer encoding）方式，就可以用这个首部列出位于报文拖挂（trailer）部分的首部集合2 |
|  Transfer-Encoding  | 告知接收端为了保证报文的可靠传输，对报文采用了什么编码方式 |
|  Update  | 给出了发送端可能想要“升级”使用的新版本或协议  |
| Via  | 显示了报文经过的中间节点（代理、网关） |
#### 　通用缓存首部
| 首　　部  | 描　　述 |
| --- | --- |
|   Cache-Control  | 用于随报文传送缓存指示 |
|  Pragma3 |  另一种随报文传送指示的方式，但并不专用于缓存 |


### 请求首部
#### 信息性首部
| 首　　部  | 描　　述 |
| --- | --- |
| Client-IP4 |  提供了运行客户端的机器的IP地址  |
| From |  提供了客户端用户的E-mail地址5   |
|Host |  给出了接收请求的服务器的主机名和端口号 |
|  Referer|   提供了包含当前请求URI的文档的URL |
|  UA-Color  | 提供了与客户端显示器的显示颜色有关的信息 |
|  UA-CPU6 |  给出了客户端CPU的类型或制造商  |
| UA-Disp |  提供了与客户端显示器（屏幕）能力有关的信息   |
|UA-OS |  给出了运行在客户端机器上的操作系统名称及版本  |
| UA-Pixels   |提供了客户端显示器的像素信息 User-Agent   将发起请求的应用程序名称告知服务器 |
#### Aceept首部
> Accept 首部为客户端提供了一种将其喜好和能力告知服务器的方式，包括它们想要什么，可以使用什么，以及最重要的，它们不想要什么。这样，服务器就可以根据这些额外信息，对要发送的内容做出更明智的决定。Accept


| 首　　部  | 描　　述 |
| --- | --- |
|  Accept  |  告诉服务器能够发送哪些媒体类型   | 
| Accept-Charset|    告诉服务器能够发送哪些字符集| 
|    Accept-Encoding |   告诉服务器能够发送哪些编码方式 | 
|   Accept-Language  |  告诉服务器能够发送哪些语言  | 
|  TE7  |  告诉服务器可以使用哪些扩展传输编码 |

####条件请求首部
> 有时客户端希望为请求加上某些限制。比如，如果客户端已经有了一份文档副本，就希望只在服务器上的文档与客户端拥有的副本有所区别时，才请求服务器传输文档。通过条件请求首部，客户端就可以为请求加上这种限制，要求服务器在对请求进行响应之前，确保某个条件为真。

| 首　　部  | 描　　述 |
| --- | --- |
| Expect |  允许客户端列出某请求所要求的服务器行为 |
|  If-Match  | 如果实体标记与文档当前的实体标记相匹配，就获取这份文档8 |
|  If-Modified-Since |  除非在某个指定的日期之后资源被修改过，否则就限制这个请求 |
|  If-None-Match  | 如果提供的实体标记与当前文档的实体标记不相符，就获取文档 |
|  If-Range  | 允许对文档的某个范围进行条件请求 |
|  If-Unmodified-Since |  除非在某个指定日期之后资源没有被修改过，否则就限制这个请求 |
|  Range|   如果服务器支持范围请求，就请求资源的指定范围|

#####安全请求首部
>HTTP 本身就支持一种简单的机制，可以对请求进行质询 / 响应认证。这种机制要求客户端在获取特定的资源之前，先对自身进行认证，这样就可以使事务稍微安全一些。

| 首　　部  | 描　　述 |
| --- | --- |
 | Authorization  |  包含了客户端提供给服务器，以便对其自身进行认证的数据| 
|    Cookie  |  客户端用它向服务器传送一个令牌——它并不是真正的安全首部，但确实隐含了安全功能10  |
 |  Cookie2  |  用来说明请求端支持的cookie版本，参见11.6.7节 | 

####代理请求首部
> 随着因特网上代理的普遍应用，人们定义了几个首部来协助其更好地工作。

| 首　　部  | 描　　述 |
| --- | --- |
| Max-Forward  | 在通往源端服务器的路径上，将请求转发给其他代理或网关的最大次数——与TRACE方法一同使用11 |
| Proxy-Authorization |  与Authorization 首部相同，但这个首部是在与代理进行认证时使用的  |
|Proxy-Connection |  与Connection 首部相同，但这个首部是在与代理建立连接时使用的|


### 响应首部

####　响应的信息性首部
| 首　　部  | 描　　述 |
| --- | --- |
 | Age   |（从最初创建开始）响应持续时间12|
 |   Public13|  服务器为其资源支持的请求方法列表 |
 |  Retry-After  | 如果资源不可用的话，在此日期或时间重试 |
 |  Server   |服务器应用程序软件的名称和版本  |
 | Title14  | 对HTML文档来说，就是HTML文档的源端给出的标题 |
 |  Warning |  比原因短语中更详细一些的警告报文 |
####协商首部
> 如果资源有多种表示方法——比如，如果服务器上有某文档的法语和德语译稿，HTTP/1.1 可以为服务器和客户端提供对资源进行协商的能力。这里列出了几个首部，服务器可以用它们来传递与可协商资源有关的信息。

| 首　　部  | 描　　述 |
| --- | --- |
| Accept-Ranges|   对此资源来说，服务器可接受的范围类型|
|   Vary  | 服务器查看的其他首部的列表，可能会使响应发生变化；也就是说，这是一个首部列表，服务器会根据这些首部的内容挑选出最适合的资源版本发送给客户端 |

####安全响应首部
> 我们已经看到过安全请求首部了，本质上这里说的就是 HTTP 的质询 / 响应认证机制的 响应 侧。我们会在第 14 章对安全问题进行详细的讨论。现在这里介绍的是一些基本的 质询 首部。


| 首　　部  | 描　　述 |
| --- | --- |
|Proxy-Authenticate |  来自代理的对客户端的质询列表  |
| Set-Cookie |  不是真正的安全首部，但隐含有安全功能；可以在客户端设置一个令牌，以便服务器对客户端进行标识15  |
| Set-Cookie2 |  与Set-Cookie 类似，RFC 2965 Cookie定义；|
| WWW-Authenticate |  来自服务器的对客户端的质询列表 |



### 实体首部
> 实体首部指的是用于应对实体主体部分的首部。比如，可以用实体首部来说明实体主体部分的数据类型。例如，可以通过下列 Content-Type 首部告知应用程序，数据是以 iso-latin-1 字符集表示的 HTML 文档： Content-Type: text/html; charset=iso-latin-1


####　实体的信息性首部


| 首　　部  | 描　　述 |
| --- | --- |
|  Allow |  列出了可以对此实体执行的请求方法  |
| Location |  告知客户端实体实际上位于何处；用于将接收端定向到资源的（可能是新的）位置（URL）上去 |

#### 内容首部

> 内容首部提供了与实体内容有关的特定信息，说明了其类型、尺寸以及处理它所需的其他有用信息。比如，Web内容首部提供了与实体内容有关的特定信息，说明了其类型、尺寸以及处理它所需的其他有用信息。比如，Web 浏览器可以通过查看返回的内容类型，得知如何显示对象.

 | 首　　部  | 描　　述 |
| --- | --- |
 | Content-Base16 |  解析主体中的相对URL时使用的基础URL |
 |  Content-Encoding  | 对主体执行的任意编码方式   |
 |Content-Language  | 理解主体时最适宜使用的自然语言 |
 |  Content-Length  | 主体的长度或尺寸 | 
 | Content-Location  | 资源实际所处的位置 |
 |  Content-MD5 |  主体的MD5校验和 |
 |  Content-Range  | 在整个资源中此实体表示的字节范围   |
 |Content-Type | 这个主体的对象类型 |

#### 实体缓存首部
> 通用的缓存首部说明了如何或什么时候进行缓存。实体的缓存首部提供了与被缓存实体有关的信息——比如，验证已缓存的资源副本是否仍然有效所需的信息，以及更好地估计已缓存资源何时失效所需的线索。

 | 首　　部  | 描　　述 |
| --- | --- |
| ETag  | 与此实体相关的实体标记17 |
|  Expires |  实体不再有效，要从原始的源端再次获取此实体的日期和时间 |
|  Last-Modified  | 这个实体最后一次被修改的日期和时间 |




